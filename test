   高效的内容检索也是社区平台的核心功能之一。
    本项目系统集成了 Elasticsearch 搜索引擎，实现了全文检索能力，能够帮助用户快速找到相关的帖子、资源和用户。

    \subsubsection{搜索引擎集成}
        项目后端通过 Elasticsearch Java API Client 来与 Elasticsearch 搜索引擎进行交互。
        首先，需要在配置类中设置 Elasticsearch 客户端：

        \begin{minted}{java}
        @Configuration
        public class ElasticsearchConfig {

            @Value("${elasticsearch.host}")
            private String host;
            
            @Value("${elasticsearch.port}")
            private int port;
            
            @Bean
            public ElasticsearchClient elasticsearchClient() {
                // 创建低级HTTP客户端
                RestClient restClient = RestClient.builder(
                    new HttpHost(host, port))
                    .setRequestConfigCallback(requestConfigBuilder -> 
                        requestConfigBuilder.setConnectTimeout(5000)
                                          .setSocketTimeout(60000))
                    .build();
                
                // 创建传输层
                ElasticsearchTransport transport = new RestClientTransport(
                    restClient, new JacksonJsonpMapper());
                    
                // 创建API客户端
                return new ElasticsearchClient(transport);
            }
        }
        \end{minted}
 
    \subsubsection{索引管理}
        项目系统定义了多个索引映射，分别用于存储不同类型的内容（帖子、资源、用户）。下面以帖子索引为例：

        \begin{minted}{java}
/**
 * 帖子ElasticSearch仓库接口
 */
@Repository
public interface PostDocumentRepository extends ElasticsearchRepository<PostDocument, Integer> {

    /**
     * 根据标题或内容搜索帖子
     * @param keyword 关键词
     * @param pageable 分页参数
     * @return 搜索结果
     */
    @Query("""
        {
            "multi_match": {
                "query": "?0",
                "fields": ["title", "content"]
            }
        }
        """)
    Page<PostDocument> findByTitleOrContentOrderByCreateTimeDesc(String keyword, Pageable pageable);

    /**
     * 根据标签搜索帖子
     * @param tag 标签名
     * @param pageable 分页参数
     * @return 搜索结果
     */
    Page<PostDocument> findByTags(String tag, Pageable pageable);

    /**
     * 根据用户ID查找帖子
     * @param userId 用户ID
     * @param pageable 分页参数
     * @return 搜索结果
     */
    Page<PostDocument> findByUserId(Integer userId, Pageable pageable);
        \end{minted}

        这里使用了中文分词器 IK Analyzer（ik\_max\_word 和 ik\_smart），以确保中文内容能够被正确分词和索引。

    \subsubsection{数据同步}
        而为确保搜索结果的实时性，项目系统实现了数据库和搜索引擎之间的数据同步机制,使用了 Listner 监听器来实现。
        当项目系统首次启动时，会自动将数据库中的帖子数据同步到 Elasticsearch 中，
        而当用户发布新帖子、更新帖子、上传新资源亦或是更新个人信息时，其相关数据都会被同步到 Elasticsearch 当中，
        下面以帖子监听器 （\texttt{PostEntityListener}）为例：

        \begin{minted}{java}
/**
 * Post实体监听器
 * 用于在Post增删改时自动同步ES索引
 */
 @Slf4j
public class PostEntityListener {
    
    /**
     * 保存或更新后同步到ES
     */
    @PostPersist
    @PostUpdate
    public void postPersistOrUpdate(Post post) {
        try {
            log.debug("触发Post实体监听：保存/更新, ID: {}", post.getId());
            // 由于监听器不是由Spring创建的，所以需要手动获取Bean
            ElasticsearchService elasticsearchService = SpringContextHolder.getBean(ElasticsearchService.class);
            elasticsearchService.syncPostToEs(post.getId());
        } catch (Exception e) {
            log.error("Post监听器同步ES失败: {}", post.getId(), e);
        }
    }
    
    /**
     * 删除后从ES移除
     */
    @PostRemove
    public void postRemove(Post post) {
        try {
            log.debug("触发Post实体监听：删除, ID: {}", post.getId());
            ElasticsearchService elasticsearchService = SpringContextHolder.getBean(ElasticsearchService.class);
            elasticsearchService.deletePostFromEs(post.getId());
        } catch (Exception e) {
            log.error("Post监听器从ES删除失败: {}", post.getId(), e);
        }
    }
} 
        \end{minted}

    \subsubsection{搜索功能实现}
        核心搜索功能则是通过构建复合查询实现，其不仅支持多字段匹配，还有结果高亮，下面仍然是以帖子为例：

        \begin{minted}{java}
        @Override
        public SearchResult<PostSearchDTO> searchPosts(String keyword, int page, int size) {
            try {
                // 构建多字段查询
                Query query = new BoolQuery.Builder()
                    .should(
                        new MultiMatchQuery.Builder()
                            .query(keyword)
                            .fields("title^3", "content", "tags^2", "username") // 字段加权
                            .type(TextQueryType.BestFields)
                            .build()._toQuery()
                    )
                    .minimumShouldMatch("1")
                    .build()._toQuery();
                    
                // 构建高亮配置
                Highlight highlight = new Highlight.Builder()
                    .fields(
                        Map.of(
                            "title", new HighlightField.Builder().build(),
                            "content", new HighlightField.Builder().numberOfFragments(3).build()
                        )
                    )
                    .preTags("<em class=\"highlight\">")
                    .postTags("</em>")
                    .build();
                    
                // 执行搜索
                SearchResponse<Map> response = elasticsearchClient.search(s -> s
                    .index(POST_INDEX)
                    .query(query)
                    .highlight(highlight)
                    .from((page - 1) * size)
                    .size(size)
                    .sort(sort -> sort.field(f -> f.field("_score").order(SortOrder.Desc)))
                    .sort(sort -> sort.field(f -> f.field("createdAt").order(SortOrder.Desc))),
                    Map.class
                );
                
                // 处理搜索结果
                List<PostSearchDTO> posts = new ArrayList<>();
                for (Hit<Map> hit : response.hits().hits()) {
                    Map<String, Object> source = hit.source();
                    Map<String, List<String>> highlights = hit.highlight();
                    
                    PostSearchDTO post = new PostSearchDTO();
                    post.setId(((Number) source.get("id")).intValue());
                    post.setUserId(((Number) source.get("userId")).intValue());
                    post.setUsername((String) source.get("username"));
                    post.setTitle((String) source.get("title"));
                    post.setContent((String) source.get("content"));
                    
                    // 应用高亮
                    if (highlights != null) {
                        if (highlights.containsKey("title")) {
                            post.setTitle(highlights.get("title").get(0));
                        }
                        if (highlights.containsKey("content")) {
                            post.setContent(String.join("...", highlights.get("content")));
                        }
                    }
                    
                    posts.add(post);
                }
                
                // 构建返回结果
                SearchResult<PostSearchDTO> result = new SearchResult<>();
                result.setTotal(response.hits().total().value());
                result.setList(posts);
                result.setPage(page);
                result.setSize(size);
                
                return result;
            } catch (Exception e) {
                log.error("帖子搜索失败: " + e.getMessage(), e);
                throw new RuntimeException("搜索服务异常", e);
            }
          }
        \end{minted}

        这样的搜索实现拥有以下几个关键特点：
        \begin{itemize}
            \item 多字段搜索：同时检索标题、内容、标签和作者名
            \item 字段加权：标题和标签的权重高于内容，提高搜索相关性
            \item 结果高亮：匹配的关键词会被高亮显示，帮助用户快速定位信息
            \item 分页支持：结果支持分页查询，优化加载性能
            \item 混合排序：先按相关性得分排序，相同得分的再按创建时间倒序排列
        \end{itemize}

    \subsubsection{前端搜索交互}
        前端实现了直观的搜索交互界面，用户可以输入关键词，选择搜索类型（全部、帖子、资源或用户），系统会实时返回匹配结果：

        \begin{minted}{html}
<template>
  <app-layout>
    <div class="search-container">
      <!-- 搜索框区域 -->
      <div class="search-header">
        <h1>搜索结果</h1>
        <div class="search-input-box">
          <el-input
            v-model="keyword"
            placeholder="搜索内容..."
            clearable
            @keyup.enter="search"
          >
            <template #append>
              <el-button @click="search">搜索</el-button>
            </template>
          </el-input>
        </div>
      </div>

      <!-- 标签页切换 -->
      <el-tabs v-model="activeTab" @tab-click="handleTabChange">
        <el-tab-pane label="全部" name="all">
          <div v-if="loading" class="loading-state">
            <el-skeleton :rows="5" animated />
          </div>
          <div v-else-if="searchResult.totalResults === 0" class="empty-state">
            <el-empty description="没有找到相关结果" />
          </div>
          <div v-else class="search-results">
            <div class="search-stats">
              共找到 <span class="highlight">{{ searchResult.totalResults }}</span> 个结果
              (帖子: {{ searchResult.totalPosts }}, 资源: {{ searchResult.totalResources }}, 用户: {{ searchResult.totalUsers }})
            </div>
            
            <!-- 展示帖子结果 -->
            <div v-if="searchResult.posts && searchResult.posts.length > 0" class="result-section">
              <h2>帖子</h2>
              <div class="result-list">
                <div v-for="item in searchResult.posts" :key="`post-${item.id}`" class="result-item" @click="navigate(item)">
                  <div class="result-title">{{ item.title }}</div>
                  <div class="result-content">{{ item.content }}</div>
                  <div class="result-meta">
                    <span class="author">作者: {{ item.author }}</span>
                    <span class="date">{{ formatDate(item.createdAt) }}</span>
                    <div class="tags">
                      <el-tag v-for="tag in item.tags" :key="tag" size="small">{{ tag }}</el-tag>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </el-tab-pane>
        
        <el-tab-pane label="帖子" name="posts">
          <post-search-results :keyword="keyword" />
        </el-tab-pane>
        
        <el-tab-pane label="资源" name="resources">
          <resource-search-results :keyword="keyword" />
        </el-tab-pane>
        
        <el-tab-pane label="用户" name="users">
          <user-search-results :keyword="keyword" />
        </el-tab-pane>
      </el-tabs>
    </div>
  </app-layout>
</template>
        \end{minted}

        搜索页面的核心实现逻辑如下：

        \begin{minted}{typescript}
// 搜索相关状态
const keyword = ref('');
const loading = ref(false);
const activeTab = ref('all');
const currentPage = ref(1);
const pageSize = ref(10);
const searchResult = ref<SearchResult>({
  totalResults: 0,
  posts: [],
  totalPosts: 0,
  resources: [],
  totalResources: 0,
  users: [],
  totalUsers: 0
});

// 执行搜索
async function performSearch() {
  if (!keyword.value.trim()) {
    return;
  }
  
  loading.value = true;
  try {
    const response = await searchAll(keyword.value, currentPage.value, pageSize.value);
    if (response.data.code === 200) {
      searchResult.value = response.data.data;
    } else {
      ElMessage.error(response.data.message || '搜索失败');
    }
  } catch (error) {
    console.error('搜索失败', error);
    ElMessage.error('搜索失败，请稍后重试');
  } finally {
    loading.value = false;
  }
}

// 处理标签切换
function handleTabChange() {
  updateUrlParams();
}

// 处理页码变化
function handlePageChange(page: number) {
  currentPage.value = page;
  updateUrlParams();
  
  if (activeTab.value === 'all') {
    performSearch();
  }
}

// 导航到详情页
function navigate(item: SearchResultItem) {
  router.push(item.url);
}
        \end{minted}

        搜索结果页面提供了多种视图切换，用户可以在"全部"、"帖子"、"资源"和"用户"标签页之间切换，查看不同类型的搜索结果，
        同时也支持分页查询，以免过多查询导致性能下降。
        同时根据第 \cref{sec:frontend-design} 节中的组件化设计，项目采用了组件化设计，将各类型的搜索结果提取为独立组件（如 \texttt{PostSearchResults}、\texttt{ResourceSearchResults} 和 
        \texttt{UserSearchResults}），提高了代码复用率和可维护性。

        搜索功能还实现了以下特点：
        \begin{itemize}
            \item \textbf{状态持久化}：搜索条件（关键词、标签页、页码）会同步到URL参数，支持页面刷新和书签收藏
            \item \textbf{优雅的加载状态}：使用骨架屏（Skeleton）展示加载状态，减少页面跳动
            \item \textbf{空结果处理}：当搜索结果为空时，显示友好的空状态提示
            \item \textbf{智能分类展示}：将不同类型的搜索结果分组展示，便于用户筛选
            \item \textbf{响应式布局}：适配不同屏幕尺寸的设备，提供一致的用户体验
        \end{itemize}

        每个搜索结果项都包含标题、内容摘要（带有关键词高亮）、发布者、发布时间等信息，帮助用户快速判断内容相关性。
        点击搜索结果项可直接导航到相应的详情页面。

        总体而言，Elasticsearch 的集成极大地增强了平台的内容检索能力，用户可以通过多种方式快速找到感兴趣的内容，
        提升了用户体验和平台的内容可发现性。